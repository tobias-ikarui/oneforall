"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const Cursor_1 = require("./Cursor");
const Tokens_1 = require("./Tokens");
class Parser {
    constructor(input) {
        this.input = input;
        this.cursor = new Cursor_1.Cursor(this.input);
    }
    get hasNext() {
        return this.cursor.hasNext;
    }
    parseNamed() {
        const tokens = [];
        let buffer = '';
        let outputBuffer = '';
        let isQuoted = false;
        let isFlag = false;
        let isFlagValue = false;
        let flagName = '';
        let isKeyword = false;
        let keywordName = '';
        while (this.cursor.hasNext) {
            const char = this.cursor.next();
            const canBeQuoted = !isQuoted && (!(isFlag && !isFlag) || isKeyword);
            if (char === '"' && buffer.length === 0 && canBeQuoted) {
                isQuoted = true;
                continue;
            }
            if (char === '-' && this.cursor.peekNext() === '-' && buffer.length === 0 && !isFlag && !isKeyword) {
                this.cursor.next();
                isFlag = true;
                continue;
            }
            if (char === '=' && buffer.length > 0 && !isKeyword && !isFlag) {
                keywordName = buffer;
                buffer = '';
                isKeyword = true;
                continue;
            }
            if (char === '\\' && this.cursor.peekNext() === '"' && isQuoted) {
                buffer += '"';
                this.cursor.next();
                continue;
            }
            if (char === '"' && isQuoted) {
                if (isFlagValue) {
                    tokens.push(new Tokens_1.NamedArgumentToken(flagName, buffer));
                    flagName = '';
                    isFlag = false;
                    isFlagValue = false;
                }
                else if (isKeyword) {
                    tokens.push(new Tokens_1.NamedArgumentToken(keywordName, buffer));
                    keywordName = '';
                    isKeyword = false;
                }
                else {
                    outputBuffer += `\"${buffer}\"`;
                    this.cursor.skipWhitespace();
                }
                buffer = '';
                isQuoted = false;
                continue;
            }
            if (char === ' ' && !isQuoted) {
                if (isFlag) {
                    if (!isFlagValue) {
                        flagName = buffer;
                        isFlagValue = true;
                    }
                    else {
                        tokens.push(new Tokens_1.NamedArgumentToken(flagName, buffer));
                        this.cursor.skipWhitespace();
                        flagName = '';
                        isFlag = false;
                        isFlagValue = false;
                    }
                }
                else if (isKeyword) {
                    tokens.push(new Tokens_1.NamedArgumentToken(keywordName, buffer));
                    this.cursor.skipWhitespace();
                    keywordName = '';
                    isKeyword = false;
                }
                else {
                    outputBuffer += `${buffer} `;
                }
                buffer = '';
                continue;
            }
            buffer += char;
        }
        if (buffer.length > 0) {
            if (isFlag) {
                if (isFlagValue)
                    tokens.push(new Tokens_1.NamedArgumentToken(flagName, buffer));
            }
            else if (isKeyword)
                tokens.push(new Tokens_1.NamedArgumentToken(keywordName, buffer));
            else
                outputBuffer += buffer;
        }
        this.cursor = new Cursor_1.Cursor(outputBuffer.trim());
        return tokens;
    }
    peekNext() {
        const currentIndex = this.cursor.index;
        const token = this.parseNext();
        this.cursor.index = currentIndex;
        return token;
    }
    parseNext() {
        let token;
        let buffer = '';
        let isQuoted = false;
        while (this.cursor.hasNext) {
            const char = this.cursor.next();
            if (char === '"' && buffer.length === 0 && !isQuoted) {
                isQuoted = true;
                continue;
            }
            if (char === '\\' && this.cursor.peekNext() === '"' && isQuoted) {
                buffer += '"';
                this.cursor.next();
                continue;
            }
            if (char === '"' && isQuoted) {
                token = new Tokens_1.PositionalArgumentToken(buffer);
                this.cursor.skipWhitespace();
                buffer = '';
                break;
            }
            if (char === ' ' && !isQuoted) {
                token = new Tokens_1.PositionalArgumentToken(buffer);
                this.cursor.skipWhitespace();
                buffer = '';
                break;
            }
            buffer += char;
        }
        if (buffer.length > 0)
            token = new Tokens_1.PositionalArgumentToken(buffer);
        return token;
    }
    consumeRemaining() {
        return this.cursor.consumeRemaining();
    }
    consumeWhile(predicate) {
        const result = this.cursor.consumeWhile(predicate);
        if (result)
            this.cursor.skipWhitespace();
        return result;
    }
    peekRemaining() {
        const currentIndex = this.cursor.index;
        const result = this.cursor.consumeRemaining();
        this.cursor.index = currentIndex;
        return result;
    }
    peekWhile(predicate) {
        const currentIndex = this.cursor.index;
        const result = this.cursor.consumeWhile(predicate);
        this.cursor.index = currentIndex;
        return result;
    }
}
exports.Parser = Parser;
