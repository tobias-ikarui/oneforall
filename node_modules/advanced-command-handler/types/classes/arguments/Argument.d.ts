import { ArgumentContext } from '../contexts';
/**
 * The validator of arguments, must return `true` if the argument is valid.
 */
declare type ArgumentValidator = (argument: string, ctx: ArgumentContext) => boolean;
/**
 * The parser of the arguments, must return a value or `null`, can be in a promise or not.
 */
declare type ArgumentParser<T> = (argument: string, ctx: ArgumentContext) => T | null | Promise<T | null>;
export declare type ArgumentFunction<T> = (options: ArgumentBuilder<T>) => Argument<T>;
/**
 * The arguments types.
 * You can add your own if you want to add arguments types.
 */
export declare enum ArgumentType {
    BOOLEAN = "boolean",
    CHANNEL = "channel",
    COMMAND = "command",
    CHOICE = "choice",
    EMOJI = "emoji",
    ENUM = "enum",
    EVENT = "event",
    FLOAT = "float",
    GUILD = "guild",
    GUILD_MEMBER = "guild_member",
    INTEGER = "integer",
    MESSAGE = "message",
    REGEX = "regex",
    ROLE = "role",
    SNOWFLAKE = "snowflake",
    STRING = "string",
    TEXT_CHANNEL = "text_channel",
    USER = "user"
}
declare type DefaultValueArgument<T> = {
    defaultValue: T;
};
declare type CoalescingArgument = {
    coalescing: boolean;
};
declare type OptionalArgument = {
    optional: boolean;
};
export declare type ArgumentBuilder<T> = Partial<(DefaultValueArgument<T> | CoalescingArgument | OptionalArgument) & {
    description: string;
}>;
export interface ArgumentOptions<T> {
    coalescing?: boolean;
    defaultValue?: T;
    description?: string;
    optional?: boolean;
}
export declare class Argument<T> {
    type: ArgumentType;
    options: ArgumentOptions<T>;
    validator: ArgumentValidator;
    parser: ArgumentParser<T>;
    constructor(type: ArgumentType, options: ArgumentOptions<T>, validator: ArgumentValidator, parser: ArgumentParser<T>);
}
export declare class CommandArgument<T> {
    name: string;
    index: number;
    /**
     * Does the argument can take multiple words.
     */
    coalescing: boolean;
    /**
     * The default value of the argument.
     */
    defaultValue: T | undefined;
    /**
     * The description of the argument, currently not used anywhere.
     */
    description: string;
    /**
     * Is the argument optional or not.
     */
    optional: boolean;
    /**
     * The parse function of the argument.
     */
    parse: ArgumentParser<T>;
    /**
     * The type of the argument.
     */
    type: ArgumentType;
    /**
     * The validate function of the argument.
     */
    validate: ArgumentValidator;
    constructor(name: string, index: number, argument: Argument<T>);
    /**
     * Is the argument not optional, doesn't have any default value and only takes one word.
     *
     * @returns - Is the argument simple.
     */
    get isSimple(): boolean;
    /**
     * Is the argument optional or has a default value.
     *
     * @returns - Does the argument can be skipped.
     */
    get isSkipable(): boolean;
}
export {};
