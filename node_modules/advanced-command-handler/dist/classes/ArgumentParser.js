"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgumentParser = void 0;
const argumentorum_1 = require("argumentorum");
const contexts_1 = require("./contexts");
const errors_1 = require("./errors");
class ArgumentParser {
    constructor(args, rawArgs) {
        this.args = args;
        this.rawArgs = rawArgs;
        this.hasParsedAllArguments = false;
        this.parser = new argumentorum_1.Parser(rawArgs.join(' '));
    }
    static invalidArgumentError(currentArgument, argumentContext) {
        return new errors_1.CommandError({
            type: errors_1.CommandErrorType.INVALID_ARGUMENT,
            data: {
                argumentContext,
                ctx: argumentContext,
            },
            message: ArgumentParser.errors.invalidArgument(currentArgument.name),
        });
    }
    static argumentNotFoundError(currentArgument, argumentContext) {
        return new errors_1.CommandError({
            type: errors_1.CommandErrorType.INVALID_ARGUMENT,
            data: {
                argumentContext,
                ctx: argumentContext,
            },
            message: ArgumentParser.errors.argumentNotFound(currentArgument.name),
        });
    }
    static argumentRequiresOneValueError(currentArgument, argumentContext) {
        return new errors_1.CommandError({
            type: errors_1.CommandErrorType.INVALID_ARGUMENT,
            data: {
                argumentContext,
                ctx: argumentContext,
            },
            message: ArgumentParser.errors.argumentRequiresOneValue(currentArgument.name),
        });
    }
    static errorInArgumentError(currentArgument, argumentContext) {
        return new errors_1.CommandError({
            type: errors_1.CommandErrorType.INVALID_ARGUMENT,
            data: {
                argumentContext,
                ctx: argumentContext,
            },
            message: ArgumentParser.errors.errorInArgument(currentArgument.name),
        });
    }
    async parseArguments(context) {
        let argsMap = new Map();
        const keywordArgs = new Map();
        this.parser.parseNamed().forEach(named => {
            const name = named.name.toLowerCase();
            keywordArgs.set(name, keywordArgs.get(name) ?? []);
            keywordArgs.get(name)?.push(named.data);
        });
        let currentArgument;
        let i = 0;
        while (true) {
            let argumentResult = null;
            currentArgument = this.args.shift();
            if (!currentArgument)
                break;
            const keywordValue = keywordArgs.get(currentArgument.name.toLowerCase());
            const hasKeywordArgs = keywordValue !== undefined;
            const actualCursorIndex = this.parser.cursor.index;
            if (!this.parser.cursor.hasNext && !hasKeywordArgs && !currentArgument.defaultValue)
                continue;
            const argumentContext = new contexts_1.ArgumentContext({
                ...context,
                index: i,
            });
            const invalidArgumentError = ArgumentParser.invalidArgumentError(currentArgument, argumentContext);
            const argumentNotFoundError = ArgumentParser.argumentNotFoundError(currentArgument, argumentContext);
            const argumentRequiresOneValueError = ArgumentParser.argumentRequiresOneValueError(currentArgument, argumentContext);
            const errorInArgumentError = ArgumentParser.errorInArgumentError(currentArgument, argumentContext);
            let toParse = hasKeywordArgs ? keywordValue[0] : this.parser.parseNext()?.data ?? '';
            let parsed = await currentArgument.parse(toParse, argumentContext);
            let error;
            if (!currentArgument.validate(toParse, argumentContext))
                error = invalidArgumentError;
            if (hasKeywordArgs && keywordValue?.length !== 1)
                error = argumentRequiresOneValueError;
            if (currentArgument.isSimple) {
                argumentResult = error ?? !parsed ? argumentNotFoundError : parsed;
            }
            else if (currentArgument.defaultValue) {
                if (!parsed && this.args.length > 0) {
                    this.parser.cursor.index = actualCursorIndex;
                    i++;
                    continue;
                }
                argumentResult = parsed ? parsed : currentArgument.defaultValue;
            }
            else if (currentArgument.optional) {
                if (!parsed && this.args.length > 0) {
                    this.parser.cursor.index = actualCursorIndex;
                    i++;
                    continue;
                }
                argumentResult = parsed;
            }
            else if (currentArgument.coalescing) {
                toParse += ` ${keywordValue?.join(' ') ?? this.parser.consumeRemaining()}`;
                const toParseCount = toParse.split(' ').length;
                if (hasKeywordArgs || toParseCount <= 0)
                    error = invalidArgumentError;
                if (hasKeywordArgs) {
                    if (toParseCount < keywordValue.length)
                        error = invalidArgumentError;
                    error = toParseCount <= 0 ? invalidArgumentError : undefined;
                }
                parsed = currentArgument.parse(toParse, argumentContext);
                argumentResult = error ?? parsed;
                if (currentArgument.optional)
                    argumentResult ?? (argumentResult = null);
                if (currentArgument.defaultValue)
                    argumentResult = currentArgument.defaultValue;
            }
            else {
                argumentResult = errorInArgumentError;
            }
            argsMap.set(currentArgument.name, argumentResult);
            console.log({
                argumentResult,
                parsed: argumentResult === parsed ? 'similar' : parsed,
                error,
                toParse,
            });
            i++;
        }
        this.hasParsedAllArguments = true;
        this.parsed = argsMap;
    }
    async resolveArgument(commandContext, name) {
        if (this.parsed?.has(name))
            return this.parsed.get(name);
        await this.parseArguments(commandContext);
        return this.parsed.get(name);
    }
    async resolveArguments(context) {
        if (this.parsed?.size === this.args.length)
            return this.parsed;
        await this.parseArguments(context);
        return this.parsed;
    }
}
exports.ArgumentParser = ArgumentParser;
ArgumentParser.errors = {
    invalidArgument: (argumentName) => `Invalid argument '${argumentName}' provided from user.`,
    argumentNotFound: (argumentName) => `Cannot resolve argument '${argumentName}', message is missing argument and argument is not optional and has no default value.`,
    argumentRequiresOneValue: (argumentName) => `Argument '${argumentName}' requires exactly one value bot none or multiple were provided.`,
    errorInArgument: (argumentName) => `Cannot resolve argument '${argumentName}', bad input from user.`,
};
