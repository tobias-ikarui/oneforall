"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.userArgument = exports.textChannelArgument = exports.regexArgument = exports.stringArgument = exports.snowflakeArgument = exports.messageArgument = exports.intArgument = exports.guildMemberArgument = exports.guildArgument = exports.floatArgument = exports.eventArgument = exports.enumArgument = exports.emojiArgument = exports.commandArgument = exports.choiceArgument = exports.channelArgument = exports.booleanArgument = void 0;
const utils_1 = require("../../utils");
const Argument_1 = require("./Argument");
function inRange(number, min, max = Infinity) {
    if (typeof number === 'string')
        number = number.length;
    return number >= min && number <= max;
}
/**
 * Creates a boolean argument.
 * The value can only be `true` or `false`.
 *
 * @param options - The options of the argument.
 * @returns - A boolean Argument.
 */
function booleanArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.BOOLEAN, options, argument => ['true', 'false'].includes(argument), argument => argument === 'true');
}
exports.booleanArgument = booleanArgument;
/**
 * Creates a channel argument.
 * The value can be a mention, an ID, or a part of a channel from the entire client.
 *
 * @param options - The options of the argument.
 * @returns - A channel Argument.
 */
function channelArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.CHANNEL, options, (argument, ctx) => (0, utils_1.isSnowflake)(argument) || ctx.message.mentions.channels.size > 0 || argument.length > 2, (_, ctx) => (0, utils_1.getThing)('channel', ctx.message));
}
exports.channelArgument = channelArgument;
/**
 * Creates a choice argument.
 * You must put the values possible as a string array.
 * The value can be anything contained in the array.
 *
 * @param options - The options of the argument.
 * @returns - A choice argument.
 */
function choiceArgument(options) {
    return new Argument_1.Argument(Argument_1.ArgumentType.CHOICE, options, argument => options.values.includes(argument), argument => options.values.find(e => e === argument) ?? null);
}
exports.choiceArgument = choiceArgument;
/**
 * Creates a command argument.
 * The value can be an alias or the name of a command.
 *
 * @param options - The options of the argument.
 * @returns - A command argument.
 */
function commandArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.COMMAND, options, (argument, ctx) => ctx.handler.getCommandAliasesAndNames().includes(argument), (argument, ctx) => ctx.handler.findCommand(argument) ?? null);
}
exports.commandArgument = commandArgument;
/**
 * Creates a emoji argument.
 * The value can be a native emoji or a custom emoji.
 *
 * @param options - The options of the argument.
 * @returns - A emoji argument.
 */
function emojiArgument(options = {}) {
    const nativeEmojiRegex = /[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD]/;
    return new Argument_1.Argument(Argument_1.ArgumentType.EMOJI, options, argument => (0, utils_1.isSnowflake)(argument) || /<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/.test(argument) || nativeEmojiRegex.test(argument), (_, ctx) => (0, utils_1.getThing)('emote', ctx.message));
}
exports.emojiArgument = emojiArgument;
/**
 * Creates a enum argument.
 * You must put an enum (or a record) of the possible values.
 * The value can be any key of the possible values and it will return the value of the entry.
 *
 * @param options - The options of the argument.
 * @returns - A enum argument.
 */
function enumArgument(options) {
    return new Argument_1.Argument(Argument_1.ArgumentType.ENUM, options, argument => Object.keys(options.values).includes(argument), argument => Object.entries(options.values).find(e => e[0] === argument)?.[1] ?? null);
}
exports.enumArgument = enumArgument;
/**
 * Creates a event argument.
 * The value can can be any event name.
 *
 * @param options - The options of the argument.
 * @returns - A event argument.
 */
function eventArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.EVENT, options, (argument, ctx) => ctx.handler.events.has(argument), (argument, ctx) => ctx.handler.events.get(argument) ?? null);
}
exports.eventArgument = eventArgument;
/**
 * Creates a float argument.
 * The value can be any int or float number.
 *
 * @param options - The options of the argument.
 * @returns - A float argument.
 */
function floatArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.FLOAT, options, argument => !Number.isNaN(Number.parseFloat(argument)), argument => Number.parseFloat(argument));
}
exports.floatArgument = floatArgument;
/**
 * Creates a guild argument.
 * The value can be an ID or a name of a guild of the client.
 *
 * @param options - The options of the argument.
 * @returns - A guild argument.
 */
function guildArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.GUILD, options, (argument, ctx) => (0, utils_1.isSnowflake)(argument) || ctx.client.guilds.cache.has(argument) || inRange(argument, 2, 100), (_, ctx) => (0, utils_1.getThing)('guild', ctx.message));
}
exports.guildArgument = guildArgument;
/**
 * Creates a guildMember argument.
 * The value can be an ID, mention, nickname or username of any member from the actual guild where the command was executed.
 * If executed in DM it will always return `null`.
 *
 * @param options - The options of the argument.
 * @returns - A guildMember argument.
 */
function guildMemberArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.GUILD_MEMBER, options, (argument, ctx) => (0, utils_1.isSnowflake)(argument) || (ctx.message.mentions.members?.size ?? 0) > 0 || inRange(argument, 1, 100), (_, ctx) => (0, utils_1.getThing)('member', ctx.message));
}
exports.guildMemberArgument = guildMemberArgument;
/**
 * Creates a int argument.
 * The value can be any integer.
 *
 * @param options - The options of the argument.
 * @returns - A int argument.
 */
function intArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.INTEGER, options, argument => !Number.isNaN(Number.parseInt(argument)), argument => Number.parseInt(argument));
}
exports.intArgument = intArgument;
/**
 * Creates a message argument.
 * The value can be any ID or URL of a message, if the value is an ID it will search in the last 100 messages of all the channels of the current guild.
 *
 * @param options - The options of the argument.
 * @returns - A message argument.
 */
function messageArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.MESSAGE, options, argument => (0, utils_1.isSnowflake)(argument) || /https:\/\/((canary|ptb).)?discord.com\/channels\/\d{17,19}\/\d{17,19}\/\d{17,19}/.test(argument), (_, ctx) => (0, utils_1.getThing)('message', ctx.message));
}
exports.messageArgument = messageArgument;
/**
 * Creates a snowflake argument.
 * The value can be any value that ressemble a snowflake.
 * @see {@link https://discord.com/developers/docs/reference#snowflakes}
 *
 * @param options - The options of the argument.
 * @returns - A snowflake argument.
 */
function snowflakeArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.SNOWFLAKE, options, utils_1.isSnowflake, argument => argument);
}
exports.snowflakeArgument = snowflakeArgument;
/**
 * Creates a string argument.
 * The value can be anything.
 * It can also be filtered using the optional `regex` option.
 *
 * @param options - The options of the argument.
 * @returns - A string argument.
 */
function stringArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.STRING, options, argument => {
        if (options.regex)
            return options.regex.test(argument);
        return true;
    }, argument => argument);
}
exports.stringArgument = stringArgument;
/**
 * Creates a regex argument.
 * The value must be any valid JS regex, it also supports flags.
 *
 * @param options - The options of the argument.
 * @returns - A regex argument.
 */
function regexArgument(options = {}) {
    const regexRegex = /^\/(.+?)\/([gimsuy]{1,6})?$/imu;
    return new Argument_1.Argument(Argument_1.ArgumentType.REGEX, options, argument => {
        let isValid = true;
        try {
            const [, regex, flags = ''] = argument.match(regexRegex);
            new RegExp(regex, flags);
        }
        catch (ignored) {
            isValid = false;
        }
        return isValid;
    }, argument => {
        try {
            const [, regex, flags = ''] = argument.match(regexRegex);
            return new RegExp(regex, flags);
        }
        catch (ignored) {
            return null;
        }
    });
}
exports.regexArgument = regexArgument;
/**
 * Creates a textChannel argument.
 * The value can be an ID, mention or name of a TextChannel or a NewsChannel.
 * If a channel is found but is not a TextChannel or a NewsChannel, it will returns null.
 *
 * @param options - The options of the argument.
 * @returns - A textChannel argument.
 */
function textChannelArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.TEXT_CHANNEL, options, (argument, ctx) => (0, utils_1.isSnowflake)(argument) || ctx.message.mentions.channels.size > 0 || inRange(argument, 1, 100), async (argument, ctx) => {
        if ((0, utils_1.isSnowflake)(argument)) {
            const channel = await ctx.client.channels.fetch(argument);
            return (0, utils_1.isTextChannelLike)(channel) ? channel : null;
        }
        return (0, utils_1.getThing)('text_channel', ctx.message);
    });
}
exports.textChannelArgument = textChannelArgument;
/**
 * Creates a user argument.
 * The value can be an ID, mention or username of an user.
 *
 * @param options - The options of the argument.
 * @returns - A user argument.
 */
function userArgument(options = {}) {
    return new Argument_1.Argument(Argument_1.ArgumentType.USER, options, (argument, ctx) => (0, utils_1.isSnowflake)(argument) || ctx.message.mentions.users.size > 0 || inRange(argument, 2, 100), (_, ctx) => (0, utils_1.getThing)('user', ctx.message));
}
exports.userArgument = userArgument;
