"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgumentParser = void 0;
const argumentorum_1 = require("argumentorum");
const contexts_1 = require("../contexts");
const errors_1 = require("../errors");
class ArgumentParser {
    constructor(args, rawArgs) {
        this.args = args;
        this.rawArgs = rawArgs;
        this.parser = new argumentorum_1.Parser(rawArgs.join(' '));
    }
    static invalidArgumentError(argumentContext) {
        return new errors_1.CommandError({
            type: errors_1.CommandErrorType.INVALID_ARGUMENT,
            data: argumentContext,
            message: ArgumentParser.errors.invalidArgument(argumentContext.currentArgument.name),
        });
    }
    static argumentNotFoundError(argumentContext) {
        return new errors_1.CommandError({
            type: errors_1.CommandErrorType.ARGUMENT_NOT_FOUND,
            data: argumentContext,
            message: ArgumentParser.errors.argumentNotFound(argumentContext.currentArgument.name),
        });
    }
    static argumentRequiresOneValueError(argumentContext) {
        return new errors_1.CommandError({
            type: errors_1.CommandErrorType.INVALID_ARGUMENT,
            data: argumentContext,
            message: ArgumentParser.errors.argumentRequiresOneValue(argumentContext.currentArgument.name),
        });
    }
    static errorInArgumentError(argumentContext) {
        return new errors_1.CommandError({
            type: errors_1.CommandErrorType.INVALID_ARGUMENT,
            data: argumentContext,
            message: ArgumentParser.errors.errorInArgument(argumentContext.currentArgument.name),
        });
    }
    async parseArguments(context) {
        let argsMap = new Map();
        const keywordArgs = new Map();
        const argsToParse = this.args.slice();
        this.parser.parseNamed().forEach(named => {
            const name = named.name.toLowerCase();
            keywordArgs.set(name, keywordArgs.get(name) ?? []);
            keywordArgs.get(name)?.push(named.data);
        });
        let currentArgument;
        let i = 0;
        while (true) {
            let argumentResult = null;
            currentArgument = argsToParse.shift();
            if (!currentArgument)
                break;
            const keywordValue = keywordArgs.get(currentArgument.name.toLowerCase());
            const hasKeywordArgs = keywordValue !== undefined;
            const actualCursorIndex = this.parser.cursor.index;
            if (!this.parser.cursor.hasNext && !hasKeywordArgs && !currentArgument.defaultValue)
                continue;
            const argumentContext = new contexts_1.ArgumentContext({
                ...context,
                index: i,
            });
            let toParse = hasKeywordArgs ? keywordValue[0] : this.parser.parseNext()?.data ?? '';
            let parsed = await currentArgument.parse(toParse, argumentContext);
            let error;
            if (!currentArgument.validate(toParse, argumentContext))
                error = ArgumentParser.invalidArgumentError(argumentContext);
            if (hasKeywordArgs && keywordValue?.length !== 1)
                error = ArgumentParser.argumentRequiresOneValueError(argumentContext);
            if (currentArgument.isSimple) {
                argumentResult = error ?? !parsed ? ArgumentParser.argumentNotFoundError(argumentContext) : parsed;
            }
            else if (currentArgument.defaultValue) {
                if (!parsed && argsToParse.length > 0)
                    this.parser.cursor.index = actualCursorIndex;
                argumentResult = parsed ?? currentArgument.defaultValue;
            }
            else if (currentArgument.optional) {
                if (!parsed && argsToParse.length > 0) {
                    this.parser.cursor.index = actualCursorIndex;
                    i++;
                    continue;
                }
                argumentResult = parsed;
            }
            else if (currentArgument.coalescing) {
                toParse += ` ${keywordValue?.join(' ') ?? this.parser.consumeRemaining()}`;
                const toParseCount = toParse.split(' ').length;
                if (hasKeywordArgs || toParseCount <= 0)
                    error = ArgumentParser.invalidArgumentError(argumentContext);
                if (hasKeywordArgs) {
                    if (toParseCount < keywordValue.length)
                        error = ArgumentParser.invalidArgumentError(argumentContext);
                    error = toParseCount <= 0 ? ArgumentParser.invalidArgumentError(argumentContext) : undefined;
                }
                parsed = currentArgument.parse(toParse, argumentContext);
                argumentResult = error ?? parsed;
                if (currentArgument.optional)
                    argumentResult ?? (argumentResult = null);
                if (currentArgument.defaultValue)
                    argumentResult = currentArgument.defaultValue;
            }
            else {
                argumentResult = ArgumentParser.errorInArgumentError(argumentContext);
            }
            argsMap.set(currentArgument.name, argumentResult);
            i++;
        }
        const argsRequiredCount = this.args.filter(a => !a.isSkipable);
        if (argsMap.size < argsRequiredCount.length) {
            for (let i = argsMap.size; i < argsRequiredCount.length; i++) {
                const currentArgument = argsRequiredCount[i];
                const argumentContext = new contexts_1.ArgumentContext({
                    ...context,
                    index: i,
                });
                argumentContext.currentArgument = currentArgument;
                argsMap.set(currentArgument.name, ArgumentParser.argumentNotFoundError(argumentContext));
            }
        }
        this.parsed = argsMap;
    }
    async resolveArgument(commandContext, name) {
        if (this.parsed?.has(name))
            return this.parsed.get(name);
        await this.parseArguments(commandContext);
        return this.parsed.get(name);
    }
    async resolveArguments(context) {
        if (this.parsed?.size === this.args.length)
            return this.parsed;
        await this.parseArguments(context);
        return this.parsed;
    }
}
exports.ArgumentParser = ArgumentParser;
ArgumentParser.errors = {
    invalidArgument: (argumentName) => `Invalid argument '${argumentName}' provided from user.`,
    argumentNotFound: (argumentName) => `Cannot resolve argument '${argumentName}', message is missing argument and argument is not optional and has no default value.`,
    argumentRequiresOneValue: (argumentName) => `Argument '${argumentName}' requires exactly one value bot none or multiple were provided.`,
    errorInArgument: (argumentName) => `Cannot resolve argument '${argumentName}', bad input from user.`,
};
