"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubCommand = exports.Command = exports.Tag = void 0;
const discord_js_1 = require("discord.js");
const CommandHandler_1 = require("../../CommandHandler");
const utils_1 = require("../../utils");
const arguments_1 = require("../arguments");
const contexts_1 = require("../contexts");
const errors_1 = require("../errors");
/**
 * # How tags should work ?
 *
 * When using commands, you want certain commands to only run on a server or in private messages etc.<br>
 * Most other CommandHandlers uses boolean properties like `guildOnly`.<br>
 * To avoid having a ton of these, I imagined a system where you have command tags and for every call, tags of the command are verified one by one.<br>
 * And this system works very smoothly !<br>
 * So if you're using the default message event
 * ({@link https://ayfri.gitbook.io/advanced-command-handler/defaults | see how to use defaults events }), tags will be checked.
 *
 * @example
 * ```ts
 * if (command.tags.includes(Tag.guildOnly) && !message.guild) {
 *     message.channel.send(`You must be on a guild to execute the ${command.name} command !`);
 * }
 * ```
 */
var Tag;
(function (Tag) {
    /**
     * Tag for commands to not run in a thread.
     */
    Tag["channelOnly"] = "channelOnly";
    /**
     * Tag for commands to only run in private messages.
     */
    Tag["dmOnly"] = "dmOnly";
    /**
     * Tag for commands to only run on a guild.
     */
    Tag["guildOnly"] = "guildOnly";
    /**
     * Tag for commands to only run on a guild and if the author is the owner of the guild.
     */
    Tag["guildOwnerOnly"] = "guildOwnerOnly";
    /**
     * Tag for commands to only run if author is an owner defined in {@link CommandHandler.owners}.
     */
    Tag["ownerOnly"] = "ownerOnly";
    /**
     * Tag for commands to only run on a guild and in an NSFW channel.
     */
    Tag["nsfw"] = "nsfw";
    /**
     * Tag for commands to only run in a thread.
     */
    Tag["threadOnly"] = "threadOnly";
})(Tag = exports.Tag || (exports.Tag = {}));
(function (Tag) {
    /**
     * Check if some tags are validated in the command context.
     *
     * @param ctx - The command context.
     * @param tags - The tags to test.
     * @returns - The tags not validated.
     */
    function check(ctx, tags) {
        const missingTags = [];
        for (const tag of tags ?? []) {
            if (tag === Tag.channelOnly && ctx.channel.isThread())
                missingTags.push(Tag.threadOnly);
            if (tag === Tag.dmOnly && ctx.channel.type !== 'DM')
                missingTags.push(Tag.dmOnly);
            if (tag === Tag.guildOnly && !ctx.guild)
                missingTags.push(Tag.guildOnly);
            if (tag === Tag.guildOwnerOnly && ctx.guild?.ownerId !== ctx.user.id)
                missingTags.push(Tag.guildOwnerOnly);
            if (tag === Tag.nsfw && ctx.channel instanceof discord_js_1.GuildChannel && !ctx.channel.nsfw)
                missingTags.push(Tag.nsfw);
            if (tag === Tag.ownerOnly && !(0, utils_1.isOwner)(ctx.user.id))
                missingTags.push(Tag.ownerOnly);
            if (tag === Tag.threadOnly && !ctx.channel.isThread())
                missingTags.push(Tag.threadOnly);
        }
        return missingTags;
    }
    Tag.check = check;
})(Tag = exports.Tag || (exports.Tag = {}));
/**
 * @see {@link https://ayfri.gitbook.io/advanced-command-handler/concepts/commands}
 */
class Command {
    constructor() {
        /**
         * The arguments of the command.
         * You can put your own custom arguments but you must add the type to the {@link ArgumentType | argument types}.
         */
        this.arguments = {};
        /**
         * The SubCommands of this command.
         *
         * @remarks Register SubCommands using the {@link Command#registerSubCommands} method.
         */
        this.subCommands = [];
    }
    /**
     * Returns the names and aliases of this command in an array.
     */
    get nameAndAliases() {
        return [this.name, ...(this.aliases ?? [])];
    }
    /**
     * Returns the names and aliases of the subCommands of this command in an array flatted.
     */
    get subCommandsNamesAndAliases() {
        return this.subCommands.map(s => s.nameAndAliases).flat();
    }
    /**
     * Get a user ID from different sources, only here to simplify code.
     *
     * @param from - Where to get ID from.
     * @returns - The ID.
     * @internal
     */
    static getSnowflake(from) {
        return from instanceof discord_js_1.Message ? from.author.id : from instanceof discord_js_1.User ? from.id : from instanceof discord_js_1.GuildMember ? from.user.id : from;
    }
    /**
     * Deletes a message if deletable.
     *
     * @param options - The options, see {@link DeleteMessageOptions}.
     * @returns - If not deletable nothing, else the deleted message or the Node.js Timer if a timeout is set.
     */
    deleteMessage(options) {
        if (!options.message.deletable)
            return;
        if (options.timeout)
            return setTimeout(options.message.delete, options.timeout);
        else
            return options.message.delete();
    }
    /**
     * Execute the run method, but perform validations before, prefer using this method in your custom Message Event.
     *
     * @param ctx - The CContext.
     * @returns - An error related to the command if any, for example : a tag not satisfied.
     */
    async execute(ctx) {
        const error = await this.validate(ctx);
        if (error)
            return new errors_1.CommandError(error);
        await this.run(ctx);
        for (const subCommand of this.subCommands) {
            if (subCommand.nameAndAliases.includes([...ctx.rawArgs].splice(0, subCommand.name.split(' ').length).join(' '))) {
                ctx = new contexts_1.SubCommandContext({
                    rawArgs: ctx.rawArgs.slice(subCommand.name.split(' ').length),
                    command: this,
                    message: ctx.message,
                    handler: ctx.handler,
                    subCommand,
                });
                const subCommandError = await subCommand.execute(ctx);
                if (subCommandError)
                    subCommandError.name = 'SubCommandError';
                return subCommandError;
            }
        }
        this.setCooldown(ctx.message);
    }
    /**
     * Get the actual cooldown of the user for this command plus when command has been executed and how many seconds to wait.
     *
     * @param from - Where to get the cooldown from, can be a user/guild/message, see types.
     * @returns - The user's cooldown.
     */
    getCooldown(from) {
        const cooldown = CommandHandler_1.CommandHandler.cooldowns.get(Command.getSnowflake(from))[this.name];
        return {
            ...cooldown,
            waitMore: cooldown.executedAt.getTime() + cooldown.cooldown * 1000 - Date.now(),
        };
    }
    /**
     * Returns the invalid permissions (not presents in {@link https://discord.js.org/#/docs/main/stable/class/Permissions?scrollTo=s-FLAGS | Permissions.FLAGS}).
     *
     * @returns - The invalid permissions put in {@link clientPermissions} & {@link userPermissions}.
     * @internal
     */
    getInvalidPermissions() {
        const permissionsFlags = [...Object.keys(discord_js_1.Permissions.FLAGS)];
        return {
            user: this.userPermissions?.filter(permission => !permissionsFlags.includes(permission)) ?? [],
            client: this.clientPermissions?.filter(permission => !permissionsFlags.includes(permission)) ?? [],
        };
    }
    /**
     * Returns the missing permissions from the client & user for a context.
     *
     * @param ctx - The context to validate permissions for.
     * @returns - The missing permissions.
     */
    getMissingPermissions(ctx) {
        const missingPermissions = {
            client: [],
            user: [],
        };
        if (!ctx.guild || !ctx.guild.available || !ctx.textChannel)
            return missingPermissions;
        if (this.clientPermissions) {
            missingPermissions.client.push(...this.clientPermissions.filter(permission => {
                if ((0, utils_1.isPermission)(permission))
                    return !ctx.textChannel?.permissionsFor(ctx.guild?.me)?.has(permission, false);
            }));
        }
        if (this.userPermissions) {
            missingPermissions.user.push(...this.userPermissions.filter(permission => {
                if ((0, utils_1.isPermission)(permission))
                    return !ctx.textChannel?.permissionsFor(ctx.member)?.has(permission, false);
            }));
        }
        if (ctx.guild.me?.permissions.has('ADMINISTRATOR'))
            missingPermissions.client = [];
        if (ctx.member?.permissions.has('ADMINISTRATOR'))
            missingPermissions.user = [];
        return missingPermissions;
    }
    /**
     * Gives the {@link tags} of this command which are not validated by the context.<br>
     * i.e. If a command is executed on a guild and the command has the `dmOnly` Tag, it will be returned.
     *
     * @param ctx - The context to test tags from.
     * @returns - Tags that are not validated by the message.
     */
    getMissingTags(ctx) {
        return Tag.check(ctx, this.tags ?? []);
    }
    /**
     * Returns true if the user is in a cooldown for this command.
     *
     * @remarks
     * If {@link cooldown} not set, this will always return `false`.
     * @param from - From where to test if user/guild/message is in a cooldown, see types.
     * @returns - Is user in a cooldown.
     */
    isInCooldown(from) {
        const id = Command.getSnowflake(from);
        return CommandHandler_1.CommandHandler.cooldowns.has(id) && Object.keys(CommandHandler_1.CommandHandler.cooldowns.get(id)).includes(this.name);
    }
    /**
     * Returns false if {@link channels} are defined for this command but the message doesn't come from one of it.
     *
     * @param ctx - The context to test where it comes from.
     * @returns - If it is on a channel required if used.
     */
    isInRightChannel(ctx) {
        if (this.channels?.length === 0)
            return true;
        return !this.channels?.find(ch => (typeof ch === 'string' ? ch === ctx.channel.id : ch.id === ctx.channel.id)) ?? true;
    }
    /**
     * Put all the required properties in {@link CommandHandler.cooldowns} plus the `setTimeout` to remove the user from the cooldowns.
     *
     * @param from - What to use to select the user to set the cooldown from, can be a guild/message/member.
     */
    setCooldown(from) {
        const cooldown = this.cooldown ?? 0;
        const id = Command.getSnowflake(from);
        if (!CommandHandler_1.CommandHandler.cooldowns.has(id))
            CommandHandler_1.CommandHandler.cooldowns.set(id, {});
        if (this.cooldown === 0 ?? !!CommandHandler_1.CommandHandler.cooldowns.get(id)[this.name])
            return;
        CommandHandler_1.CommandHandler.cooldowns.get(id)[this.name] = {
            executedAt: from instanceof discord_js_1.Message ? from.createdAt : new Date(),
            cooldown,
        };
        setTimeout(() => delete CommandHandler_1.CommandHandler.cooldowns.get(id)[this.name], cooldown * 1000);
    }
    /**
     * Get the signature of this command.
     *
     * @example
     * // The `help` command with an optional `command` commandArgument argument.
     * ```
     * help [command]
     * ```
     * @param options - The options for the signature, show the type of the arguments or the default values.
     * @returns - The signature of this command or subCommand.
     */
    signature(options) {
        if (!this.arguments)
            return '';
        let result = this.name;
        Object.entries(this.arguments).forEach(([name, arg], index) => {
            const commandArgument = new arguments_1.CommandArgument(name, index, arg);
            let signature = '';
            signature += commandArgument.isSkipable ? '[' : '<';
            signature += commandArgument.name;
            if (options?.showTypes)
                signature += `: ${commandArgument.type.toLowerCase()}`;
            if (commandArgument.defaultValue && options?.showDefaultValues)
                signature += `= ${commandArgument.defaultValue}`;
            signature += commandArgument.isSkipable ? ']' : '>';
            result += ` ${signature}`;
        });
        return result;
    }
    /**
     * Returns the signature of the command plus the signature of the subCommands of this command.
     *
     * @example
     * // The `help` command with an optional `command` commandArgument argument and a `all` subCommand with no arguments.
     * ```
     * help [command]
     * help all
     * ```
     * @param options - The options for the signature, show the type of the arguments or the default values.
     * @returns - The signatures of the command.
     */
    signatures(options) {
        let result = `${this.signature(options)}\n`;
        result += this.subCommands.map(subCommand => `${this.name} ${subCommand.signature(options)}`).join(`\n`);
        return result;
    }
    /**
     * Validate a command, returning an error if any of the validation methods are not valid.
     *
     * @param ctx - The CommandContext.
     * @returns - The error if any.
     */
    async validate(ctx) {
        if (this.isInCooldown(ctx.message))
            return {
                message: 'User is in a cooldown.',
                type: errors_1.CommandErrorType.COOLDOWN,
                data: this.getCooldown(ctx.message),
            };
        if (!this.isInRightChannel(ctx))
            return {
                message: 'This command is not in the correct channel.',
                type: errors_1.CommandErrorType.WRONG_CHANNEL,
            };
        const missingPermissions = this.getMissingPermissions(ctx);
        const missingTags = this.getMissingTags(ctx);
        if (missingPermissions.client.length)
            return {
                message: 'The bot is missing permissions.',
                type: errors_1.CommandErrorType.CLIENT_MISSING_PERMISSIONS,
                data: missingPermissions.client.sort(),
            };
        if (missingPermissions.user.length)
            return {
                message: 'User is missing permissions.',
                type: errors_1.CommandErrorType.USER_MISSING_PERMISSIONS,
                data: missingPermissions.client.sort(),
            };
        if (missingTags.length)
            return {
                message: 'There are missing tags for the message.',
                type: errors_1.CommandErrorType.MISSING_TAGS,
                data: missingTags,
            };
        if (Object.values(this.arguments).length) {
            const argsMap = await ctx.resolveArguments();
            const args = [...(argsMap?.values() ?? [])];
            const argsError = args.find(arg => arg instanceof errors_1.CommandError);
            if (argsError) {
                return {
                    message: argsError.message,
                    data: argsError.data,
                    type: argsError.type,
                };
            }
        }
    }
    /**
     * Creates a new SubCommand for the command.
     *
     * @remarks Make sure to creates the Subcommands in the {@link Command#registerSubCommands} method.
     * @param name - The name of the SubCommand.
     * @param options - The options of the Subcommand.
     * @param callback - The callback executed when the SubCommand is executed.
     * @returns - The SubCommand itself.
     */
    subCommand(name, options, callback) {
        if (this.subCommands.map(c => c.name).includes(name))
            return;
        if (typeof options !== 'object') {
            callback = options;
            options = {};
        }
        const subCommand = new SubCommand(name, options, callback);
        this.subCommands.push(subCommand);
        utils_1.Logger.comment(`Loaded subcommand '${this.name} ${name}'.`, 'SubCommandLoading');
        return subCommand;
    }
}
exports.Command = Command;
/**
 * @see {@link https://ayfri.gitbook.io/advanced-command-handler/concepts/commands/subcommands}
 * @remarks
 * This class is not in the SubCommand file because otherwise it won't compile because of circular because of the {@link Command.subCommands} property.
 */
class SubCommand extends Command {
    /**
     * Creates a new SubCommand.
     *
     * @remarks Make sure to creates the Subcommands in the {@link Command#registerSubCommands} method.
     * @param name - The name of the SubCommand.
     * @param options - The options of the Subcommand.
     * @param runFunction - The callback executed when the SubCommand is executed.
     */
    constructor(name, options = {}, runFunction) {
        super();
        this.name = name;
        this.aliases = options.aliases;
        this.channels = options.channels;
        this.description = options.description;
        this.tags = options.tags;
        this.usage = options.usage;
        this.arguments = options.arguments ?? {};
        this.runFunction = runFunction;
    }
    /**
     * The method executed when the SubCommand is executed.
     *
     * @param ctx - The SubCommandContext.
     * @returns - Any.
     */
    async run(ctx) {
        return this.runFunction(ctx);
    }
}
exports.SubCommand = SubCommand;
