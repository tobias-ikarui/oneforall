"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgumentType = exports.userArgument = exports.textChannelArgument = exports.regexArgument = exports.stringArgument = exports.snowflakeArgument = exports.messageArgument = exports.intArgument = exports.guildMemberArgument = exports.guildArgument = exports.floatArgument = exports.eventArgument = exports.enumArgument = exports.emojiArgument = exports.commandArg = exports.choiceArgument = exports.channelArgument = exports.booleanArgument = exports.CommandArgument = exports.Argument = void 0;
const utils_1 = require("../utils");
class Argument {
    constructor(type, options, validator, parser) {
        this.type = type;
        this.options = options;
        this.validator = validator;
        this.parser = parser;
    }
}
exports.Argument = Argument;
class CommandArgument {
    constructor(name, index, argument) {
        this.name = name;
        this.index = index;
        this.validate = argument.validator;
        this.coalescing = argument.options.coalescing ?? false;
        this.defaultValue = argument.options.defaultValue ?? undefined;
        this.description = argument.options.description ?? '';
        this.optional = argument.options.optional ?? false;
        this.type = argument.type;
        this.parse = argument.parser;
    }
    get isSimple() {
        return !this.optional && !this.coalescing && !this.defaultValue;
    }
}
exports.CommandArgument = CommandArgument;
function isSnowflake(value) {
    return /\d{17,19}/.test(value);
}
function booleanArgument(options = {}) {
    return new Argument(ArgumentType.BOOLEAN, options, argument => ['true', 'false'].includes(argument), argument => argument === 'true');
}
exports.booleanArgument = booleanArgument;
function channelArgument(options = {}) {
    return new Argument(ArgumentType.CHANNEL, options, (argument, ctx) => isSnowflake(argument) || ctx.message.mentions.channels.size > 0 || argument.length > 2, (_, ctx) => utils_1.getThing('channel', ctx.message));
}
exports.channelArgument = channelArgument;
function choiceArgument(options) {
    return new Argument(ArgumentType.CHOICE, options, argument => options.values.includes(argument), argument => options.values.find(e => e === argument) ?? null);
}
exports.choiceArgument = choiceArgument;
function commandArg(options = {}) {
    return new Argument(ArgumentType.COMMAND, options, (argument, ctx) => ctx.handler.getCommandAliasesAndNames().includes(argument), (argument, ctx) => ctx.handler.findCommand(argument) ?? null);
}
exports.commandArg = commandArg;
function emojiArgument(options = {}) {
    return new Argument(ArgumentType.EMOJI, options, argument => isSnowflake(argument) || /<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/.test(argument), (_, ctx) => utils_1.getThing('emote', ctx.message));
}
exports.emojiArgument = emojiArgument;
function enumArgument(options) {
    return new Argument(ArgumentType.ENUM, options, argument => Object.keys(options.values).includes(argument), argument => Object.entries(options.values).find(e => e[0] === argument)?.[1] ?? null);
}
exports.enumArgument = enumArgument;
function eventArgument(options = {}) {
    return new Argument(ArgumentType.EVENT, options, (argument, ctx) => ctx.handler.events.has(argument), (argument, ctx) => ctx.handler.events.get(argument) ?? null);
}
exports.eventArgument = eventArgument;
function floatArgument(options = {}) {
    return new Argument(ArgumentType.FLOAT, options, argument => !Number.isNaN(Number.parseFloat(argument)), argument => Number.parseFloat(argument));
}
exports.floatArgument = floatArgument;
function guildArgument(options = {}) {
    return new Argument(ArgumentType.GUILD, options, (argument, ctx) => isSnowflake(argument) || ctx.client.guilds.cache.has(argument), (_, ctx) => utils_1.getThing('guild', ctx.message));
}
exports.guildArgument = guildArgument;
function guildMemberArgument(options = {}) {
    return new Argument(ArgumentType.GUILD_MEMBER, options, (argument, ctx) => isSnowflake(argument) || (ctx.message.mentions.members?.size ?? 0) > 0 || argument.length > 2, (_, ctx) => utils_1.getThing('member', ctx.message));
}
exports.guildMemberArgument = guildMemberArgument;
function intArgument(options = {}) {
    return new Argument(ArgumentType.INTEGER, options, argument => !Number.isNaN(Number.parseInt(argument)), argument => Number.parseInt(argument));
}
exports.intArgument = intArgument;
function messageArgument(options = {}) {
    return new Argument(ArgumentType.MESSAGE, options, argument => isSnowflake(argument) || /https:\/\/((canary|ptb).)?discord.com\/channels\/\d{17,19}\/\d{17,19}\/\d{17,19}/.test(argument), (_, ctx) => utils_1.getThing('message', ctx.message));
}
exports.messageArgument = messageArgument;
function snowflakeArgument(options = {}) {
    return new Argument(ArgumentType.SNOWFLAKE, options, isSnowflake, argument => argument);
}
exports.snowflakeArgument = snowflakeArgument;
function stringArgument(options = {}) {
    return new Argument(ArgumentType.STRING, options, argument => {
        if (options.regex)
            return options.regex.test(argument);
        return true;
    }, argument => argument);
}
exports.stringArgument = stringArgument;
function regexArgument(options = {}) {
    const regexRegex = /^\/([\w\W]+)\/([gimsuy]{1,6})?$/gimu;
    return new Argument(ArgumentType.REGEX, options, argument => {
        let isValid = true;
        try {
            const [, regex, flags = ''] = argument.match(regexRegex);
            new RegExp(regex, flags);
        }
        catch (ignored) {
            isValid = false;
        }
        return isValid;
    }, argument => {
        try {
            const [, regex, flags = ''] = argument.match(regexRegex);
            return new RegExp(regex, flags);
        }
        catch (ignored) {
            return null;
        }
    });
}
exports.regexArgument = regexArgument;
function textChannelArgument(options = {}) {
    return new Argument(ArgumentType.TEXT_CHANNEL, options, (argument, ctx) => isSnowflake(argument) || ctx.message.mentions.channels.size > 0 || argument.length > 2, async (argument, ctx) => {
        if (isSnowflake(argument)) {
            const channel = await ctx.client.channels.fetch(argument);
            return utils_1.isTextChannelLike(channel) ? channel : null;
        }
        return utils_1.getThing('text_channel', ctx.message);
    });
}
exports.textChannelArgument = textChannelArgument;
function userArgument(options = {}) {
    return new Argument(ArgumentType.USER, options, (argument, ctx) => isSnowflake(argument) || ctx.message.mentions.users.size > 0 || argument.length > 2, (_, ctx) => utils_1.getThing('user', ctx.message));
}
exports.userArgument = userArgument;
var ArgumentType;
(function (ArgumentType) {
    ArgumentType["BOOLEAN"] = "boolean";
    ArgumentType["CHANNEL"] = "channel";
    ArgumentType["COMMAND"] = "command";
    ArgumentType["CHOICE"] = "choice";
    ArgumentType["EMOJI"] = "emoji";
    ArgumentType["ENUM"] = "enum";
    ArgumentType["EVENT"] = "event";
    ArgumentType["FLOAT"] = "float";
    ArgumentType["GUILD"] = "guild";
    ArgumentType["GUILD_MEMBER"] = "guild_member";
    ArgumentType["INTEGER"] = "integer";
    ArgumentType["MESSAGE"] = "message";
    ArgumentType["REGEX"] = "regex";
    ArgumentType["ROLE"] = "role";
    ArgumentType["SNOWFLAKE"] = "snowflake";
    ArgumentType["STRING"] = "string";
    ArgumentType["TEXT_CHANNEL"] = "text_channel";
    ArgumentType["USER"] = "user";
})(ArgumentType = exports.ArgumentType || (exports.ArgumentType = {}));
