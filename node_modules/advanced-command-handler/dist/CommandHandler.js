"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandHandler = void 0;
const discord_js_1 = require("discord.js");
const events_1 = require("events");
const fs_1 = require("fs");
const path_1 = require("path");
const _1 = require("./");
const defaultCommands = __importStar(require("./defaults/commands/"));
const defaultEvents = __importStar(require("./defaults/events"));
var CommandHandler;
(function (CommandHandler) {
    /**
     * The version of the handler.
     */
    CommandHandler.version = require('../package.json').version;
    /**
     * The event emitter for the CommandHandler.
     *
     * @eventProperty
     */
    CommandHandler.emitter = new events_1.EventEmitter();
    /**
     * The commands registered by the CommandHandler.
     */
    CommandHandler.commands = new discord_js_1.Collection();
    /**
     * The cooldowns mapped by ID and cooldown user.
     *
     * <strong>A simple explication</strong> :<br>
     * When a user executes a command with a cooldown, a new value is added.
     * ```typescript
     * [anyID]: {
     *    [commandName]: {
     *        executedAt: Date,
     *        cooldown: [command cooldown]
     *    }
     * }
     * ```
     * So cooldowns are mapped by IDs (can be anything, user IDs recommended) then mapped by commands.
     */
    CommandHandler.cooldowns = new discord_js_1.Collection();
    /**
     * The events registered by the EventHandler.
     *
     * @remarks
     * These events may not be bound to the {@link client}.
     */
    CommandHandler.events = new discord_js_1.Collection();
    CommandHandler.commandsDir = '';
    CommandHandler.eventsDir = '';
    CommandHandler.owners = [];
    CommandHandler.prefixes = [];
    /**
     * The client of the handler, null before {@link launch} function executed.
     */
    CommandHandler.client = null;
    /**
     * @internal
     */
    let useMentionAsPrefix;
    /**
     * Execute the event you want from the {@link emitter | listener} throughout the CommandHandler.
     *
     * @typeParam K - Event names of the CommandHandler listener.
     * @param eventName - The event name.
     * @param args - The arguments to pass.
     */
    function emit(eventName, ...args) {
        CommandHandler.emitter.emit(eventName, args);
    }
    CommandHandler.emit = emit;
    /**
     * Adds a listener for the {@link eventName} event.
     *
     * @typeParam K - Event names of the CommandHandler listener.
     * @param eventName - The event name.
     * @param fn - The callback to execute.
     */
    function on(eventName, fn) {
        CommandHandler.emitter.on(eventName, fn);
    }
    CommandHandler.on = on;
    /**
     * Adds a one-time listener for the {@link eventName} event.
     *
     * @typeParam K - Event names of the CommandHandler listener.
     * @param eventName - The event name.
     * @param fn - The callback to execute.
     */
    function once(eventName, fn) {
        CommandHandler.emitter.once(eventName, fn);
    }
    CommandHandler.once = once;
    /**
     * Returns the list of names and aliases of all commands, useful to find a command by name.
     *
     * @returns - All the names and aliases in a flat array.
     */
    function getCommandAliasesAndNames() {
        return CommandHandler.commands.map(c => [c.name, ...(c.aliases ?? [])]).flat();
    }
    CommandHandler.getCommandAliasesAndNames = getCommandAliasesAndNames;
    /**
     * Find a command by name or alias.
     *
     * @param name - The name or alias of the command.
     * @returns - The command found or `undefined`.
     */
    function findCommand(name) {
        return CommandHandler.commands.find(c => c.nameAndAliases.includes(name));
    }
    CommandHandler.findCommand = findCommand;
    /**
     * Add the defaults events to your CommandHandler.
     *
     * @remarks
     * Must use after {@link CommandHandler.create}.
     * @see {@link https://ayfri.gitbook.io/advanced-command-handler/defaults | Default Events}
     * @param options - The options for the default events.
     * @returns - Itself so that afterward you can chain with other functions.
     */
    function useDefaultEvents(options) {
        _1.Logger.info('Loading default events.', 'Loading');
        defaultEvents.MessageCreateEvent.options = options?.messageCreateOptions ?? {};
        for (let event of Object.values(defaultEvents)) {
            const instance = new event();
            if (options?.exclude?.includes(instance.name))
                continue;
            CommandHandler.events.set(instance.name, instance);
            _1.Logger.comment(`Default ${_1.Logger.setColor('green', instance.name)} event loaded.`, 'Loading');
        }
        _1.Logger.info(`Default events loaded. (${Object.values(defaultEvents).length})`, 'Loading');
        return CommandHandler;
    }
    CommandHandler.useDefaultEvents = useDefaultEvents;
    /**
     * Add the defaults commands to your CommandHandler.
     *
     * @remarks
     * Must use after {@link CommandHandler.create}.
     * @see {@link https://ayfri.gitbook.io/advanced-command-handler/defaults | Default Commands}
     * @param options - The options for the default commands.
     * @returns - Itself so that afterward you can chain with other functions.
     */
    function useDefaultCommands(options) {
        _1.Logger.info('Loading default commands.', 'Loading');
        defaultCommands.HelpCommand.options = options?.helpOptions ?? {};
        for (let command of Object.values(defaultCommands)) {
            const instance = new command();
            if (options?.exclude?.includes(instance.name))
                continue;
            CommandHandler.commands.set(instance.name, instance);
            _1.Logger.comment(`Default ${_1.Logger.setColor('green', instance.name)} command loaded.`, 'Loading');
        }
        _1.Logger.info(`Default commands loaded. (${Object.keys(defaultCommands).length})`, 'Loading');
        return CommandHandler;
    }
    CommandHandler.useDefaultCommands = useDefaultCommands;
    /**
     * Creates a new CommandHandler, wrap up the last one.
     *
     * @param options - Options for creating a new CommandHandler.
     * @see {@link https://ayfri.gitbook.io/advanced-command-handler/concepts/command-handler#creating-your-commandhandler}
     * @returns - Itself so that afterward you can chain with other functions.
     */
    function create(options) {
        options.saveLogsInFile?.forEach(_1.Logger.saveInFile);
        _1.Logger.log(`Advanced Command Handler ${CommandHandler.version} by Ayfri.`, 'Loading', 'red');
        CommandHandler.commandsDir = options.commandsDir ?? '';
        CommandHandler.eventsDir = options.eventsDir ?? '';
        CommandHandler.owners = options.owners ?? [];
        CommandHandler.prefixes = options.prefixes ?? [];
        useMentionAsPrefix = options.useMentionAsPrefix ?? true;
        if (!CommandHandler.commandsDir)
            _1.Logger.warn("No 'commandsDir' specified, commands apart default commands won't load.");
        if (!CommandHandler.eventsDir)
            _1.Logger.warn("No 'eventsDir' specified, events apart default events won't load.");
        process.on('warning', error => _1.Logger.error(`An error occurred. \n${error.stack}`));
        process.on('uncaughtException', error => _1.Logger.error(`An error occurred. \n${error.stack}`));
        emit('create', options);
        return CommandHandler;
    }
    CommandHandler.create = create;
    /**
     * Launches the CommandHandler, log in the client and load commands/events.
     *
     * @param options - Options for launching the CommandHandler, see {@link CreateCommandHandlerOptions}.
     * @see {@link https://ayfri.gitbook.io/advanced-command-handler/concepts/command-handler#launching-the-commandhandler}
     * @returns - Itself in a promise so that afterward you can chain with other functions.
     */
    async function launch(options) {
        CommandHandler.client = new _1.AdvancedClient(options.token, options.clientOptions);
        emit('launch', options);
        try {
            await loadCommands(CommandHandler.commandsDir);
            await loadEvents(CommandHandler.eventsDir);
            _1.Logger.comment('Loading subcommands.', 'SubCommandLoading');
            CommandHandler.commands.forEach(c => c.registerSubCommands?.());
            _1.Logger.comment('Binding events to client.', 'Binding');
            CommandHandler.events.forEach(event => event.bind(CommandHandler.client));
            _1.Logger.info(`${CommandHandler.client?.eventNames().length ?? 0} events loaded & bind.`, 'Loading');
        }
        catch (e) {
            _1.Logger.error((e instanceof Error ? e : new Error(String(e))).stack, 'Loading');
        }
        await CommandHandler.client.login(options.token);
        if (options.presence && !options.presences)
            CommandHandler.client.user.setPresence(options.presence);
        if (options.presences && options.presences.length > 0) {
            const cycle = options.cycleBetweenPresences ?? true;
            if (cycle && options.presences.length > 1) {
                let index = 0;
                CommandHandler.presencesInterval = setInterval(() => {
                    CommandHandler.client.user.setPresence(options.presences[index]);
                    index++;
                    if (index > options.presences.length - 1)
                        index = 0;
                }, (options.cycleDuration ?? 60) * 1000);
            }
            else {
                CommandHandler.client.user.setPresence(options.presences[0]);
            }
        }
        if (useMentionAsPrefix) {
            CommandHandler.prefixes.push(`<@${CommandHandler.client?.user?.id}> `);
            CommandHandler.prefixes.push(`<@!${CommandHandler.client?.user?.id}> `);
        }
        if (options.addBotAndTeamOwnersToOwners !== false) {
            const appOwner = (await CommandHandler.client.application?.fetch())?.owner;
            if (appOwner) {
                if (appOwner instanceof discord_js_1.Team)
                    CommandHandler.owners.push(...appOwner.members.filter(m => m.membershipState === 'ACCEPTED').map(m => m.id));
                else
                    CommandHandler.owners.push(appOwner.id);
            }
        }
        emit('launched');
        return CommandHandler;
    }
    CommandHandler.launch = launch;
    /**
     * Get the prefix from the prefixes defined in {@link CommandHandler.launch} or null.
     *
     * @param message - The message to get the prefix for.
     * @returns - The prefix found or null if not.
     */
    function getPrefixFromMessage(message) {
        return CommandHandler.prefixes.find(prefix => message.content.startsWith(prefix));
    }
    CommandHandler.getPrefixFromMessage = getPrefixFromMessage;
    /**
     * Load a command from the directory & filename.
     *
     * @param path - The path of the command folder.
     * @param name - The name of the command including the extension.
     * @returns - The command itself.
     */
    async function loadCommand(path, name) {
        let command = await Promise.resolve().then(() => __importStar(require((0, path_1.join)(process.cwd(), path, name))));
        if ('default' in command)
            command = command.default;
        if (command.constructor.name === 'Object')
            command = Object.values(command)[0];
        const instance = new command();
        if (!instance)
            throw new Error(`Command given name or path is not valid.\nPath : ${path}\nName:${name}`);
        if (!instance.category)
            instance.category = path.split(/[\\/]/).pop();
        const invalidPermissions = instance.getInvalidPermissions();
        if (invalidPermissions.client.length > 0)
            throw new _1.CommandHandlerError(`Invalid client permissions for '${instance.name}' command.\nInvalid Permissions: '${invalidPermissions.client.sort().join(',')}'`, 'Loading');
        if (invalidPermissions.user.length > 0)
            throw new _1.CommandHandlerError(`Invalid user permissions for '${instance.name}' command.\nInvalid Permissions: '${invalidPermissions.user.sort().join(',')}'`, 'Loading');
        CommandHandler.commands.set(instance.name, instance);
        emit('loadCommand', instance);
        _1.Logger.comment(`Loading the command : ${_1.Logger.setColor('gold', name)}`, 'Loading');
        return instance;
    }
    CommandHandler.loadCommand = loadCommand;
    /**
     * Load all the commands from a directory.
     *
     * @remarks
     * The path must be a directory containing sub-directories.
     * @param path - The path of the directory to load the commands from.
     */
    async function loadCommands(path) {
        if (!path)
            return;
        const dirs = await fs_1.promises.readdir(path);
        _1.Logger.info('Loading commands.', 'Loading');
        _1.Logger.comment(`Categories : (${dirs.length})`, 'Loading');
        if (dirs.length) {
            for (const dir of dirs) {
                const commandsPath = (0, path_1.join)(path, dir);
                const files = await fs_1.promises.readdir(commandsPath);
                if (!files.length)
                    continue;
                _1.Logger.comment(`Commands in the category '${dir}' : (${files.length})`, 'Loading');
                for (const file of files) {
                    await loadCommand(commandsPath, file);
                }
            }
        }
        _1.Logger.info(`${CommandHandler.commands.size} commands loaded.`, 'Loading');
    }
    CommandHandler.loadCommands = loadCommands;
    /**
     * Load an event from the directory and filename.
     *
     * @param path - The path of the event folder.
     * @param name - The name of the event including the extension.
     * @returns - The event itself.
     */
    async function loadEvent(path, name) {
        let event = await Promise.resolve().then(() => __importStar(require((0, path_1.join)(process.cwd(), path, name))));
        if ('default' in event)
            event = event.default;
        if (event.constructor.name === 'Object')
            event = Object.values(event)[0];
        const instance = new event();
        if (!event)
            throw new Error(`Event given name or path is not valid.\nPath : ${path}\nName:${name}`);
        CommandHandler.events.set(instance.name, instance);
        _1.Logger.comment(`Event ${_1.Logger.setColor('green', instance.name)} loaded : ${_1.Logger.setColor('gold', `${name.split('.')[0]}.js`)}`, 'Loading');
        return instance;
    }
    CommandHandler.loadEvent = loadEvent;
    /**
     * Load all the events from a directory.
     *
     * @param path - The path of the directory to load the events from.
     */
    async function loadEvents(path) {
        if (!path)
            return;
        const files = await fs_1.promises.readdir(path);
        _1.Logger.info('Loading events.', 'Loading');
        _1.Logger.comment(`Events : (${files.length})`, 'Loading');
        if (files.length)
            for (const file of files)
                await loadEvent(path, file);
    }
    CommandHandler.loadEvents = loadEvents;
    /**
     * Unloads an event.
     *
     * @param name - The event to unload.
     */
    function unloadEvent(name) {
        if (CommandHandler.events.delete(name))
            _1.Logger.info(`${name} event unloaded.`, 'UnLoading');
        else
            _1.Logger.warn(`${name} event not found.`, 'UnLoading');
    }
    CommandHandler.unloadEvent = unloadEvent;
    /**
     * Unloads a command.
     *
     * @param name - The command to unload.
     */
    function unloadCommand(name) {
        if (CommandHandler.commands.delete(name))
            _1.Logger.info(`${name} command unloaded.`, 'UnLoading');
        else
            _1.Logger.warn(`Command '${name}' not found.`, 'UnLoading');
    }
    CommandHandler.unloadCommand = unloadCommand;
})(CommandHandler = exports.CommandHandler || (exports.CommandHandler = {}));
