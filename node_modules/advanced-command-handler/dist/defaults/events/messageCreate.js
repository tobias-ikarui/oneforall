"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageEvent = void 0;
const __1 = require("../..");
const classes_1 = require("../../classes");
class MessageEvent extends classes_1.Event {
    constructor() {
        super(...arguments);
        this.name = 'messageCreate';
    }
    async run(ctx, message) {
        if (message.author.bot || message.system)
            return;
        const prefix = __1.CommandHandler.getPrefixFromMessage(message);
        if (!prefix)
            return;
        const [commandArg, ...args] = message.content.slice(prefix.length).trim().split(/ +/g);
        const command = await (0, __1.getThing)('command', commandArg.toLowerCase().normalize());
        if (!command)
            return;
        const commandContext = new classes_1.CommandContext({
            rawArgs: args,
            command,
            message,
            handler: ctx.handler,
        });
        try {
            const error = await command.execute(commandContext);
            if (error) {
                switch (error.type) {
                    case classes_1.CommandErrorType.CLIENT_MISSING_PERMISSIONS:
                        return (0, __1.permissionsError)(commandContext, error.data, true);
                    case classes_1.CommandErrorType.USER_MISSING_PERMISSIONS:
                        return (0, __1.permissionsError)(commandContext, error.data);
                    case classes_1.CommandErrorType.MISSING_TAGS:
                        return (0, __1.argError)(commandContext, `There are missing tags for the message: \n\`${error.data
                            .map(tag => classes_1.Tag[tag])
                            .sort()
                            .join('\n')
                            .toUpperCase()}\``);
                    case classes_1.CommandErrorType.WRONG_CHANNEL:
                        return commandContext.send('This command is not in the correct channel.');
                    case classes_1.CommandErrorType.COOLDOWN:
                        return commandContext.send(`You are on a cooldown! Please wait **${error.data.waitMore / 1000}**s.`);
                    case classes_1.CommandErrorType.ERROR:
                        return (0, __1.codeError)(commandContext, error);
                    case classes_1.CommandErrorType.ARGUMENT_NOT_FOUND:
                        return (0, __1.argError)(commandContext, error.message.replaceAll(/'(\w+?)'/g, '`$1`'));
                    case classes_1.CommandErrorType.INVALID_ARGUMENT:
                        return (0, __1.argError)(commandContext, error.message.replaceAll(/'(\S+?)'/g, '`$1`'));
                }
            }
            else {
                __1.Logger.log(`${message.author.tag} has executed the command ${__1.Logger.setColor('red', command.name)}.`);
            }
        }
        catch (error) {
            await (0, __1.codeError)(commandContext, error instanceof Error ? error : new Error(String(error)));
        }
    }
}
exports.MessageEvent = MessageEvent;
