"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageCreateEvent = void 0;
const __1 = require("../..");
const classes_1 = require("../../classes");
class MessageCreateEvent extends classes_1.Event {
    constructor() {
        super(...arguments);
        this.name = 'messageCreate';
    }
    async run(ctx, message) {
        if (MessageCreateEvent.options.excludeBots !== false && message.author.bot)
            return;
        if (message.system)
            return;
        const prefix = __1.CommandHandler.getPrefixFromMessage(message);
        if (!prefix)
            return;
        const [commandArg, ...args] = message.content.slice(prefix.length).trim().split(/ +/g);
        const command = await (0, __1.getThing)('command', commandArg.toLowerCase().normalize());
        if (!command)
            return;
        const commandContext = new classes_1.CommandContext({
            rawArgs: args,
            command,
            message,
            handler: ctx.handler,
        });
        if (MessageCreateEvent.options.globalTags) {
            const missingTags = classes_1.Tag.check(commandContext, MessageCreateEvent.options.globalTags);
            if (missingTags.length > 0) {
                return (0, __1.argError)(commandContext, `There are missing global tags for the message: \n\`${missingTags
                    .map(tag => classes_1.Tag[tag])
                    .sort()
                    .join('\n')
                    .toUpperCase()}\``);
            }
        }
        try {
            const error = await command.execute(commandContext);
            if (error) {
                switch (error.type) {
                    case classes_1.CommandErrorType.CLIENT_MISSING_PERMISSIONS:
                        return (0, __1.permissionsError)(commandContext, error.data, true);
                    case classes_1.CommandErrorType.USER_MISSING_PERMISSIONS:
                        return (0, __1.permissionsError)(commandContext, error.data);
                    case classes_1.CommandErrorType.MISSING_TAGS:
                        return (0, __1.argError)(commandContext, `There are missing tags for the message: \n\`${error.data
                            .map(tag => classes_1.Tag[tag])
                            .sort()
                            .join('\n')
                            .toUpperCase()}\``);
                    case classes_1.CommandErrorType.WRONG_CHANNEL:
                        return commandContext.send('This command is not in the correct channel.');
                    case classes_1.CommandErrorType.COOLDOWN:
                        return commandContext.send(`You are on a cooldown! Please wait **${error.data.waitMore / 1000}**s.`);
                    case classes_1.CommandErrorType.ERROR:
                        return (0, __1.codeError)(commandContext, error);
                    case classes_1.CommandErrorType.ARGUMENT_NOT_FOUND:
                        return (0, __1.argError)(commandContext, error.message.replaceAll(/'(\w+?)'/g, '`$1`'));
                    case classes_1.CommandErrorType.INVALID_ARGUMENT:
                        return (0, __1.argError)(commandContext, error.message.replaceAll(/'(\S+?)'/g, '`$1`'));
                }
            }
            else {
                __1.Logger.log(`${message.author.tag} has executed the command ${__1.Logger.setColor('red', command.name)}.`);
            }
        }
        catch (error) {
            const sendWhenError = MessageCreateEvent.options.sendWhenError;
            const toSend = typeof sendWhenError === 'string' ? { content: sendWhenError } : { embed: sendWhenError };
            const err = error instanceof Error ? error : new Error(String(error));
            if (MessageCreateEvent.options.sendCodeError === false) {
                if (sendWhenError)
                    await commandContext.reply(toSend);
            }
            else if (MessageCreateEvent.options.sendCodeErrorOnlyToOwners === false) {
                await (0, __1.codeError)(commandContext, err);
            }
            else {
                if ((0, __1.isOwner)(commandContext.user.id))
                    await (0, __1.codeError)(commandContext, err);
                else if (sendWhenError)
                    await commandContext.reply(toSend);
            }
        }
    }
}
exports.MessageCreateEvent = MessageCreateEvent;
MessageCreateEvent.options = {};
