"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelpCommand = void 0;
const dayjs_1 = __importDefault(require("dayjs"));
const duration_1 = __importDefault(require("dayjs/plugin/duration"));
const discord_js_better_embed_1 = require("discord.js-better-embed");
const __1 = require("../../");
const classes_1 = require("../../classes");
dayjs_1.default.extend(duration_1.default);
/**
 * Group an array by property with a predicate.
 *
 * @typeParam T - The type of the values of the array.
 * @typeParam K - The property of the values.
 * @param array - The array to group.
 * @param predicate - The predicate to get the property.
 * @returns - The array grouped by {@link K}.
 */
function groupBy(array, predicate) {
    return array.reduce((previous, currentItem) => {
        const group = predicate(currentItem);
        if (!previous[group])
            previous[group] = [];
        previous[group].push(currentItem);
        return previous;
    }, {});
}
class HelpCommand extends classes_1.Command {
    constructor() {
        super(...arguments);
        this.aliases = ['h'];
        this.arguments = {
            command: (0, __1.commandArgument)({ optional: true }),
        };
        this.category = 'utils';
        this.description = 'Get the list of commands or more information for one.';
        this.name = 'help';
    }
    async run(ctx) {
        if (ctx.isCallingASubCommand)
            return;
        const command = await ctx.argument('command');
        if (command)
            await HelpCommand.sendCommandHelp(ctx, command);
        else
            await HelpCommand.sendGlobalHelp(ctx);
    }
    static async sendGlobalHelp(ctx) {
        const commandList = groupBy([...ctx.handler.commands.values()], c => c.category);
        const embed = discord_js_better_embed_1.BetterEmbed.fromTemplate('complete', {
            client: ctx.client,
            title: 'List of the commands.',
            description: `\`${ctx.handler.prefixes[0]}${ctx.commandName} <command>\` to get more information on a command.`,
        });
        if (HelpCommand.options.globalMenuUseList) {
            let commands = Object.values(commandList).flat();
            if (HelpCommand.options.globalMenuExcludeCommands) {
                commands = commands.filter(c => c.nameAndAliases.some(c => HelpCommand.options.globalMenuExcludeCommands.includes(c)));
            }
            commands.sort((a, b) => a.name.localeCompare(b.name)).forEach(c => embed.addField(c.signature(), c.description ?? 'No description provided.'));
        }
        else {
            Object.entries(commandList)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .forEach(([category, commands]) => {
                if (HelpCommand.options.globalMenuExcludeCommands) {
                    commands = commands.filter(c => c.nameAndAliases.some(c => HelpCommand.options.globalMenuExcludeCommands.includes(c)));
                }
                if (!commands.length)
                    return;
                embed.addField(category, `\`${commands
                    .filter(m => m.category === category)
                    .map(c => c.name)
                    .sort()
                    .join('`, `')}\``);
            });
        }
        const message = await ctx.reply({ embed });
        if (HelpCommand.options.deleteMessageAfterDelay)
            setInterval(message.delete, HelpCommand.options.deleteMessageAfterDelay * 1000);
        return message;
    }
    static async sendCommandHelp(ctx, command) {
        if (!__1.CommandHandler.commands.map(c => c.name).includes(command.name))
            return;
        let description = `**Description** : ${command.description ?? 'No description provided.'}\n`;
        description += `**Category** : \`${command.category}\`\n`;
        description += `Can you use it here : **${(await command.validate(ctx)) ? 'No' : 'Yes'}**`;
        const embed = discord_js_better_embed_1.BetterEmbed.fromTemplate('complete', {
            client: ctx.client,
            title: `Information on command ${command.name} :`,
            description,
        });
        if (command.usage)
            embed.addField('Usage :', command.usage);
        else
            embed.addField('Syntax :', command.signatures({ showDefaultValues: true }));
        if (command.aliases)
            embed.addField('Aliases : ', `\`${command.aliases.sort().join('\n')}\``);
        if (command.tags)
            embed.addField('Tags :', `\`${command.tags
                .map(t => (typeof t === 'string' ? t : classes_1.Tag[t]))
                .sort()
                .join('\n')
                .toUpperCase()}\``);
        if (command.cooldown)
            embed.addField('Cooldown :', `${dayjs_1.default.duration(command.cooldown, 'seconds').asSeconds()} seconds`);
        if (command.subCommands) {
            let subCommandDescription = '';
            command.subCommands.forEach(s => {
                if (s.description)
                    subCommandDescription += `\`${command.name} ${s.signature()}\` : ${s.description}\n`;
            });
            if (subCommandDescription.length > 0)
                embed.addField('SubCommands :', subCommandDescription);
        }
        embed.cutIfTooLong();
        return ctx.reply({ embed });
    }
    async registerSubCommands() {
        this.subCommand('all', {
            aliases: ['a', 'list', 'ls'],
            description: 'List all commands available.',
        }, HelpCommand.sendGlobalHelp);
    }
}
exports.HelpCommand = HelpCommand;
HelpCommand.options = {};
