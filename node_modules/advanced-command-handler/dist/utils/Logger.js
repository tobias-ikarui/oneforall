"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.colors = exports.LogType = exports.LogLevel = void 0;
const chalk_1 = __importDefault(require("chalk"));
const dayjs_1 = __importDefault(require("dayjs"));
const fs = __importStar(require("fs"));
const paths = __importStar(require("path"));
const util_1 = require("util");
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["OFF"] = 0] = "OFF";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["WARNING"] = 2] = "WARNING";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    LogLevel[LogLevel["EVENT"] = 4] = "EVENT";
    LogLevel[LogLevel["LOG"] = 5] = "LOG";
    LogLevel[LogLevel["DEBUG"] = 6] = "DEBUG";
    LogLevel[LogLevel["COMMENT"] = 7] = "COMMENT";
    LogLevel[LogLevel["ALL"] = 7] = "ALL";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
exports.LogType = {
    error: 'red',
    warn: 'yellow',
    info: 'blue',
    event: 'green',
    log: 'default',
    debug: 'white',
    comment: 'gray',
};
exports.colors = {
    red: '#b52825',
    orange: '#e76a1f',
    gold: '#deae17',
    yellow: '#eeee23',
    green: '#3ecc2d',
    teal: '#11cc93',
    blue: '#2582ff',
    indigo: '#524cd9',
    violet: '#7d31cc',
    magenta: '#b154cf',
    pink: '#d070a0',
    brown: '#502f1e',
    black: '#000000',
    grey: '#6e6f77',
    white: '#ffffff',
    default: '#cccccc',
};
/**
 * @see {@link https://ayfri.gitbook.io/advanced-command-handler/utilities/logger}
 */
class Logger {
    /**
     * @remarks
     * Avoid using it because you can't do anything with it.
     */
    constructor() { }
    /**
     * Save from now the logs in the file.
     *
     * @param path - The path of the file.
     */
    static saveInFile(path) {
        const file = paths.resolve(process.cwd(), path);
        if (!fs.existsSync(file)) {
            Logger.comment(`File ${Logger.setColor('violet', file)} not found, creating new one, logs will be saved into it.`, 'LoggingWriter');
            fs.appendFileSync(file, '');
        }
        else {
            Logger.comment(`File ${Logger.setColor('violet', file)} found, logs will be saved into it.`, 'LoggingWriter');
        }
        Logger.savingFiles.push(file);
    }
    /**
     * Log a message in the console as a comment.
     *
     * @remarks
     * Using the grey color.
     * @param message - The message to log, can be anything.
     * @param title - The title of the log.
     */
    static comment(message, title = 'comment') {
        if (Logger.LEVEL < LogLevel.COMMENT || Logger.isIgnored(title, LogLevel.COMMENT))
            return;
        Logger.process(message, exports.LogType.comment, title);
    }
    /**
     * Log a message in the console as an error.
     *
     * @remarks
     * Using the red color.
     * @param message - The message to log, can be anything.
     * @param title - The title of the log.
     */
    static error(message, title = 'error') {
        if (Logger.LEVEL < LogLevel.ERROR || Logger.isIgnored(title, LogLevel.ERROR))
            return;
        Logger.process(message, exports.LogType.error, title);
    }
    /**
     * Log a message in the console as an event.
     *
     * @remarks
     * Using the green color.
     * @param message - The message to log, can be anything.
     * @param title - The title of the log.
     */
    static event(message, title = 'event') {
        if (Logger.LEVEL < LogLevel.EVENT || Logger.isIgnored(title, LogLevel.EVENT))
            return;
        Logger.process(message, exports.LogType.event, title);
    }
    /**
     * Log a message in the console as an info.
     *
     * @remarks
     * Using the blue color.
     * @param message - The message to log, can be anything.
     * @param title - The title of the log.
     */
    static info(message, title = 'info') {
        if (Logger.LEVEL < LogLevel.INFO || Logger.isIgnored(title, LogLevel.INFO))
            return;
        Logger.process(message, exports.LogType.info, title);
    }
    /**
     * Log a message in the console.
     *
     * @remarks
     * Using the # color.
     * @param message - The message to log, can be anything.
     * @param title - The title of the log.
     * @param color - The color of the log.
     */
    static log(message, title = 'log', color = exports.LogType.log) {
        if (Logger.LEVEL < LogLevel.LOG || Logger.isIgnored(title, LogLevel.LOG))
            return;
        Logger.process(message, color, title);
    }
    /**
     * Set the color for the following text.
     *
     * @param color - The color of the text.
     * @param text - The text to colorize.
     * @returns - The text colored, adapted for consoles using escape sequences.
     */
    static setColor(color = exports.colors.default, text = '') {
        let finalColor;
        if ((color = Logger.getColorFromColorResolvable(color)))
            finalColor = chalk_1.default.hex(color);
        else
            throw new Error('Waiting for a log type, color or HexColor but receive something else.');
        return text ? finalColor(text) : finalColor();
    }
    /**
     * Log a message in the console as a debug.
     *
     * @remarks
     * Using the default color.
     * @param message - The message to log, can be anything.
     * @param title - The title of the log.
     */
    static debug(message, title = 'debug') {
        if (Logger.LEVEL < LogLevel.DEBUG || Logger.isIgnored(title, LogLevel.DEBUG))
            return;
        Logger.process(message, exports.LogType.debug, title);
    }
    /**
     * Log a message in the console as a warning.
     *
     * @remarks
     * Using the yellow color.
     * @param message - The message to log, can be anything.
     * @param title - The title of the log.
     */
    static warn(message, title = 'warn') {
        if (Logger.LEVEL < LogLevel.WARNING)
            return;
        Logger.process(message, exports.LogType.warn, title);
    }
    /**
     * Test if a title and level is ignored.
     *
     * @param title - The title of the log.
     * @param level - The level of the log.
     * @returns - Is it ignored or not.
     * @internal
     */
    static isIgnored(title, level) {
        const ignores = Logger.ignores.map(s => (typeof s === 'string' ? [s, LogLevel.ALL] : [s[0], s[1]]));
        return ignores.filter(i => i[0].toUpperCase() === title.toUpperCase()).some(i => (typeof i[1] === 'string' ? LogLevel[i[1]] >= level : i[1] >= level));
    }
    /**
     * Log something in the console and transform the ColorResolvable into an ASCII Escape Sequence containing the color.
     *
     * @param text - The text to log.
     * @param color - The color of the text.
     * @param title - The title of the text.
     * @internal
     */
    static process(text, color = 'debug', title = '') {
        if (Logger.LEVEL === LogLevel.OFF)
            return;
        const datePart = `[${(0, dayjs_1.default)().format('YYYY/MM/DD HH:mm:ss.SSS')}]`;
        const titlePart = `[${title.toUpperCase()}]`;
        text = typeof text === 'object' ? (0, util_1.inspect)(text) : text.toString();
        let textPart = text;
        text = text
            .split(' ')
            .map((word) => /\d/.test(word) && !/\x1b\[\d+((;\d+){1,4})?m/.test(word) ? word.replace(/\d+/, (match) => chalk_1.default.yellow(match)) : word)
            .join(' ');
        color = propertyInEnum(exports.LogType, color) ?? color;
        text = `${Logger.setColor('#847270', datePart)}${Logger.setColor(color, `${titlePart} ${text + chalk_1.default.reset()}`)}`;
        console.log(text);
        Logger.savingFiles.forEach((s, index) => {
            if (!fs.existsSync(s)) {
                Logger.savingFiles.splice(index, 1);
                Logger.warn(`File ${Logger.setColor('violet', s)} not found, removed from files to save logs.`, 'LoggingWriter');
            }
            else {
                textPart = textPart.replace(/\[(\d{1,3};){0,6}\d{1,3}m/gm, '');
                fs.appendFileSync(s, `${datePart}${titlePart} ${textPart}\n`);
            }
        });
    }
    /**
     * Returns a color in hexadecimal without the sharp from a ColorResolvable.
     *
     * @remarks
     * Returns the default color if it cannot be resolved.
     * @param color - The ColorResolvable.
     * @returns - The color.
     * @internal
     */
    static getColorFromColorResolvable(color) {
        return (propertyInEnum(exports.LogType, propertyInEnum(exports.colors, color) ?? '') ??
            propertyInEnum(exports.colors, color) ??
            propertyInEnum(exports.LogType, color)?.match(/#[0-9|a-f]{6}/i)?.[0] ??
            color.match(/#[0-9|a-f]{6}/i)?.[0] ??
            exports.colors.default.substring(1, 7));
    }
}
exports.Logger = Logger;
/**
 * Let you set the minimum level required for a log to be sent to console.<br><br>
 * For example if you set the level to `LogLevel.LOG`, the `Logger.debug()` and `Logger.comments()` methods won't log anything.
 */
Logger.LEVEL = LogLevel.ALL;
/**
 * Let you ignore Logs by title or by titles and levels.
 *
 * @example
 * // This will ignore any logs with the title 'mylogs'.
 * Logger.ignores.push('mylogs');
 *
 * // This will ignore any logs with the title 'mylogs', and the level 'LOG' or less.
 * Logger.ignores.push(['mylogs', LogLevel.LOG]);
 *
 * // It can also work by setting the string version of the LogLevel.
 * Logger.ignores.push(['mylogs', 'LOG']);
 */
Logger.ignores = [];
/**
 * The files where the logs are saved.
 */
Logger.savingFiles = [];
/**
 * Get the value of an enum.
 *
 * @typeParam V - An object.
 * @param enumObject - The enum as an object.
 * @param property - The property to get.
 * @returns - The value from the key of the enum or undefined if not found.
 * @internal
 */
function propertyInEnum(enumObject, property) {
    return enumObject[property] ?? undefined;
}
